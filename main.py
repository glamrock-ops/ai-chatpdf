# Streamlit Cloudì— ë°°í¬í•˜ê¸° ìœ„í•´ requirements.txt íŒŒì¼ì—ë„ pysqlite3-binary íŒ¨í‚¤ì§€ë¥¼ ì¶”ê°€í•˜ê³ , ê·¸ë¦¬ê³  ì•„ë˜ ì£¼ì„ì„ í•´ì œí•˜ì—¬ì„œ ì§„í–‰ ë¶€íƒë“œë¦½ë‹ˆë‹¤. 
# __import__('pysqlite3')
# import sys
# sys.modules['sqlite3'] = sys.modules.pop('pysqlite3')

# ==========================================
# [1] ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸° - ë„êµ¬ìƒì ì—´ê¸°
# ==========================================
# langchain_communityì—ì„œ ë¡œë”ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
from langchain_community.document_loaders import PyPDFLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter

# ==========================================
# ì„ë² ë”© ëª¨ë¸
# ==========================================
from langchain_openai import OpenAIEmbeddings
from langchain.retrievers.multi_query import MultiQueryRetriever  
from langchain_openai import ChatOpenAI   
# from langchain_ollama import OllamaEmbeddings  #ì„ë² ë”© ì—”ì§„ ollamaë¡œ ìˆ˜ì •í•˜ì—¬
# from langchain.retrievers.multi_query import MultiQueryRetriever  # ì„ë² ë”©ìš©
# from langchain_ollama import ChatOllama                           # LLM ì±„íŒ…ìš© ëª¨ë“ˆ ì¶”ê°€

# ==========================================
# vector DB
# ==========================================
from langchain_chroma import Chroma


# ==========================================
# [7] (ì¶”ê°€) ìµœì¢… ì‘ë‹µ ìƒì„± (Generation)
# ==========================================
from langchain import hub
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

# ==========================================
#
# ==========================================
import streamlit as st
import tempfile
import os

# ==========================================
# .env íŒŒì¼ ë¡œë“œ
# .env íŒŒì¼ì— ìˆëŠ” ë¹„ë°€ë²ˆí˜¸(API KEY)ë¥¼ ë¡œë”©í•©ë‹ˆë‹¤.
# ==========================================
from dotenv import load_dotenv
load_dotenv()

#ì œëª©
st.title("ChatPDF")
st.write("---")


# ==========================================
# [2] PDF ë¡œë“œ ë° ë¶„í•  (ì¬ë£Œì†ì§ˆ)
# ==========================================
# # 1. PDF íŒŒì¼ ë¡œë“œí•˜ê¸° (ì±… ê°€ì ¸ì˜¤ê¸° - íŒŒì¼ ì´ë¦„ì´ í´ë”ì— ìˆëŠ”ì§€ ê¼­ í™•ì¸í•˜ì„¸ìš”!)
# loader = PyPDFLoader("unsu.pdf")

# # 2. í˜ì´ì§€ë³„ë¡œ ìª¼ê°œì„œ ê°€ì ¸ì˜¤ê¸°
# pages = loader.load_and_split()

#íŒŒì¼ ì—…ë¡œë“œ
uploaded_file = st.file_uploader("PDF íŒŒì¼ì„ ì˜¬ë ¤ì£¼ì„¸ìš”!", type=['pdf'])
st.write("---")

def pdf_to_document(uploaded_file):
    # 1. ì„ì‹œ í´ë”(í˜¸í…” ë°©) í•˜ë‚˜ ë¹Œë¦½ë‹ˆë‹¤.
    # (ì´ í•¨ìˆ˜ê°€ ëë‚˜ê±°ë‚˜ temp_dir ë³€ìˆ˜ê°€ ì‚¬ë¼ì§€ë©´ í´ë”ë„ ìë™ ì‚­ì œë¨)
    temp_dir = tempfile.TemporaryDirectory()

    # 2. ê·¸ ë°© ì•ˆì— "ë‚´íŒŒì¼.pdf"ë¼ëŠ” ì´ë¦„í‘œ(ê²½ë¡œ)ë¥¼ ë§Œë“­ë‹ˆë‹¤.
    # ì˜ˆ: C:\Users\Temp\askdjfh\unsu.pdf
    temp_filepath = os.path.join(temp_dir.name, uploaded_file.name)
    # with ë¸”ë¡ ì•ˆì— ìˆëŠ” ì½”ë“œê°€ ë‹¤ ëë‚˜ê±°ë‚˜, 
    # í˜¹ì€ ì¤‘ê°„ì— ì—ëŸ¬ê°€ í„°ì ¸ë„ ë¬´ì¡°ê±´ íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ ë‹«ì•„ì£¼ëŠ”(Close) ì—­í• ì„ í•©ë‹ˆë‹¤. 
    # ê·¸ë˜ì„œ íŒŒì¼ ë‹¤ë£° ë• ë¬´ì¡°ê±´ withë¥¼ ì”ë‹ˆë‹¤.
    with open(temp_filepath, "wb") as f:
       f.write(uploaded_file.getvalue()) 
       # 3. í•  ì¼ ë‹¤ í•˜ê³  ë¸”ë¡(ë“¤ì—¬ì“°ê¸°)ì„ ë¹ ì ¸ë‚˜ì˜¤ë©´...
        # ìë™ìœ¼ë¡œ f.close()ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤! (ì‹¬ì§€ì–´ ì—ëŸ¬ê°€ ë‚˜ë„ ë‹«í˜!)
    # 4. ì´ì œ "ì‹¤ì œ íŒŒì¼"ì´ ìƒê²¼ìœ¼ë‹ˆ, ë¡œë”í•œí…Œ ê·¸ ìœ„ì¹˜ë¥¼ ì•Œë ¤ì¤ë‹ˆë‹¤.
    loader = PyPDFLoader(temp_filepath)
    pages = loader.load_and_split()
    return pages

#ì—…ë¡œë“œëœ íŒŒì¼ ì²˜ë¦¬
if uploaded_file is not None:
    pages = pdf_to_document(uploaded_file)
    # 3.Splitter . í…ìŠ¤íŠ¸ ë¶„í• ê¸° (ê°€ìœ„ì§ˆ)
    # ë¹„ìœ : ì±…ì„ í†µì§¸ë¡œ ì½ìœ¼ë©´ ì²´í•˜ë‹ˆê¹Œ, AIê°€ í•œì…ì— ë¨¹ê¸° ì¢‹ê²Œ ê°€ìœ„ë¡œ ì˜¤ë¦½ë‹ˆë‹¤.
    # chunk_size=1000: í•œ ì¡°ê°ì— ê¸€ì 1000ê°œ ì •ë„ ë“¤ì–´ê°€ê²Œ ìë¦„
    # chunk_overlap=200: ìë¥¼ ë•Œ ë¬¸ë§¥ì´ ëŠê¸°ì§€ ì•Šê²Œ ì•ë’¤ ë‚´ìš©ì„ ì¡°ê¸ˆì”© ê²¹ì³ì„œ ìë¦„
    text_splitter = RecursiveCharacterTextSplitter(
        # Set a really small chunk size, just to show.
        chunk_size=300,
        chunk_overlap=20,
        length_function=len,
        is_separator_regex=False,
    )
    # text_splitter = RecursiveCharacterTextSplitter(
    #     chunk_size=1000,
    #     chunk_overlap=200,
    #     length_function=len,
    #     is_separator_regex=False,
    # )

    # ì‹¤ì œë¡œ ìë¥´ëŠ” ì‘ì—… ìˆ˜í–‰
    # pages(ì±… ì „ì²´) -> texts(ì˜ë¦° ì¢…ì´ ì¡°ê°ë“¤)
    texts = text_splitter.split_documents(pages)
    print(f"   -> í…ìŠ¤íŠ¸ë¥¼ {len(texts)}ê°œì˜ ë©ì–´ë¦¬(Chunk)ë¡œ ìª¼ê°°ìŠµë‹ˆë‹¤.")
    # print(texts[0])

    # ==========================================
    # [3] Embedding (ë²ˆì—­)
    # ==========================================
    # 1. ì„ë² ë”© ëª¨ë¸ (ë²ˆì—­ê¸°)
    # ë¹„ìœ : í•œê¸€ ë¬¸ì¥ì„ ì»´í“¨í„°ê°€ ì´í•´í•  ìˆ˜ ìˆëŠ” 'ìˆ«ì ì¢Œí‘œ(ë²¡í„°)'ë¡œ ë³€í™˜í•´ì£¼ëŠ” ë²ˆì—­ê¸°ì…ë‹ˆë‹¤.
    # ê¸€ìì˜ 'ì˜ë¯¸'ë¥¼ ìˆ«ìë¡œ ë°”ê¿‰ë‹ˆë‹¤. (ì˜ˆ: ì‚¬ê³¼=[0.1, 0.5], ë°°=[0.1, 0.6])
    #-------------- openAI --------------------
    #Embedding
    embeddings_model = OpenAIEmbeddings(
        model="text-embedding-3-large", 
        # api_keyëŠ” .envì—ì„œ ì•Œì•„ì„œ ì°¾ì•„ê°‘ë‹ˆë‹¤.    
    )
    #-----------------ollama----------------------
    # #  ì„ë² ë”© ëª¨ë¸ ì¤€ë¹„ (ì´ë¯¸ ì¼œì ¸ ìˆëŠ” ë¼ë§ˆë¥¼ ì‚¬ìš©)
    # # embeddings = OllamaEmbeddings(model="llama3.1:8b") # [ìˆ˜ì • ì „]

    # # ì„ë² ë”© ëª¨ë¸ ì¤€ë¹„
    # # (í„°ë¯¸ë„ì—ì„œ 'ollama pull nomic-embed-text'ë¥¼ ë¨¼ì € ì‹¤í–‰í–ˆì–´ì•¼ í•¨)
    # embeddings_model = OllamaEmbeddings(model="nomic-embed-text") # [ìˆ˜ì • í›„] ê°€ë³ê³  ì„±ëŠ¥ ì¢‹ì€ ì„ë² ë”© ì „ìš© ëª¨ë¸

    # print("2. ë²¡í„° DBë¥¼ ìƒì„±í•˜ëŠ” ì¤‘... (ë©”ëª¨ë¦¬ì— ìƒì„± ì¤‘, ë„ë©´ ì‚¬ë¼ì§)")

    # ==========================================


    # ==========================================
    # [4] Vector DB ìƒì„± ( chromadb ) ì €ì¥ - ë§ˆë²•ì˜ ì„œëì¥ 
    # ==========================================
    # ìºì‹± ë¬¸ì œ ë°œìƒì‹œ ì•„ë˜ ì½”ë“œë¥¼ 2ì¤„ì„ ì£¼ì„í•´ì œ í•˜ì—¬ì„œ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
    # import chromadb
    # chromadb.api.client.SharedSystemClient.clear_system_cache()

    #Chroma DB
    # Chroma DB ìƒì„± (ì—¬ê¸°ì„œ í…Œì´ë¸” ìƒì„± + ë°ì´í„° ì‚½ì…ì´ ë™ì‹œì— ì¼ì–´ë‚¨)
    # 2. Chroma DB (ë§ˆë²•ì˜ ì„œëì¥)
    # ë¹„ìœ : ìœ„ì—ì„œ ë§Œë“  ìˆ«ì ì¢Œí‘œ(ì„ë² ë”©)ë¥¼ ì €ì¥í•˜ëŠ” ì„œëì¥ì…ë‹ˆë‹¤.
    # ì¼ë°˜ DBëŠ” 'ê°€ë‚˜ë‹¤ìˆœ'ìœ¼ë¡œ ì°¾ì§€ë§Œ, ì´ ì„œëì¥ì€ 'ì˜ë¯¸ê°€ ë¹„ìŠ·í•œ ìˆœ'ìœ¼ë¡œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    # texts(ì¢…ì´ì¡°ê°)ë¥¼ embeddings_model(ë²ˆì—­ê¸°)ë¡œ ë³€í™˜í•´ì„œ db(ì„œë)ì— ë„£ìŠµë‹ˆë‹¤.
    
    # ìºì‹± ë¬¸ì œ ë°œìƒì‹œ ì•„ë˜ ì½”ë“œë¥¼ 2ì¤„ì„ ì£¼ì„í•´ì œ í•˜ì—¬ì„œ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
    # import chromadb
    # chromadb.api.client.SharedSystemClient.clear_system_cache()

    db = Chroma.from_documents(texts, embeddings_model)  # ê²½ë¡œ(persist_directory)ê°€ ì—†ìœ¼ë¯€ë¡œ ë©”ëª¨ë¦¬ì— ë§Œë“¤ê³ , ë„ë©´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.
    # ==========================================

    #User Input
    st.header("PDFì—ê²Œ ì§ˆë¬¸í•´ë³´ì„¸ìš”!!")
    question = st.text_input("ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”")

    if st.button("ì§ˆë¬¸í•˜ê¸°"):

        with st.spinner("wait for it..."):

            # ==========================================
            # [5] Retriever (ê²€ìƒ‰ê¸°) ì„¤ì • - (ë„ì„œê´€ ì‚¬ì„œ ì±„ìš©)
            # ==========================================

            #question = "ì•„ë‚´ê°€ ë¨¹ê³  ì‹¶ì–´í•˜ëŠ” ìŒì‹ì€ ë¬´ì—‡ì´ì•¼?" 


            #-------------- openAI --------------------
            # ë‹µë³€ì„ í•´ì¤„ ë˜‘ë˜‘í•œ AI (LLM) ì„¤ì •
            llm = ChatOpenAI(temperature=0)

            # MultiQueryRetriever (ëˆˆì¹˜ ë¹ ë¥¸ ì‚¬ì„œ)
            # ë¹„ìœ : ì‚¬ìš©ìê°€ ê°œë–¡ê°™ì´ ì§ˆë¬¸í•´ë„, AIê°€ ì°°ë–¡ê°™ì´ ì—¬ëŸ¬ ë²„ì „ìœ¼ë¡œ ì§ˆë¬¸ì„ ë°”ê¿”ì„œ ê²€ìƒ‰í•´ì¤ë‹ˆë‹¤.
            # from_llm: ì‚¬ì„œë¥¼ ìë¦¬ì— ì•‰íˆëŠ” ê³¼ì • (ì•„ì§ ê²€ìƒ‰ ì•ˆ í•¨, ì¤€ë¹„ë§Œ ì‹œí‚´)
            retriever_from_llm = MultiQueryRetriever.from_llm(
                retriever=db.as_retriever(),    # ì–´ë–¤ ì„œëì„ ë’¤ì§ˆì§€ ì•Œë ¤ì¤Œ
                llm=llm                         # ì§ˆë¬¸ì„ ì´í•´í•  ë‘ë‡Œ(LLM) ì œê³µ
            )

            # ==========================================
            # [7] (ì¤‘ìš”!) RAG íŒŒì´í”„ë¼ì¸ ì„¤ê³„ (ìˆ˜ë„ê´€ ê³µì‚¬)
            # ==========================================
            #Prompt Template

            # 1. í”„ë¡¬í”„íŠ¸ (AIì—ê²Œ ì£¼ëŠ” ì§€ë ¹ì„œ)
            # {context}: ê²€ìƒ‰ëœ ë¬¸ì„œ ë‚´ìš©ì´ ë“¤ì–´ê°ˆ ìë¦¬
            # {question}: ì‚¬ìš©ìì˜ ì§ˆë¬¸ì´ ë“¤ì–´ê°ˆ ìë¦¬

            # 1.1 hub.pull("rlm/rag-prompt") (ë‹¤ìš´ë¡œë“œ ë°›ê¸°) â˜ï¸
            # ì±…ì— ë‚˜ì˜¨ ë°©ì‹ì…ë‹ˆë‹¤.
            # ë°©ì‹: LangChain Hub(ë­ì²´ì¸ í—ˆë¸Œ) ë¼ëŠ” 'í”„ë¡¬í”„íŠ¸ ë„ì„œê´€'ì—ì„œ ë‚¨ë“¤ì´ ì˜ ë§Œë“¤ì–´ë‘” í”„ë¡¬í”„íŠ¸ë¥¼ ì¸í„°ë„·ìœ¼ë¡œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì…ë‹ˆë‹¤.
            # ì˜ë¯¸: "rlm"ì´ë¼ëŠ” ì•„ì´ë””ë¥¼ ì“°ëŠ” ì‚¬ëŒì´ ì˜¬ë¦° "rag-prompt"ë¼ëŠ” ì´ë¦„ì˜ ì–‘ì‹ì„ ê°€ì ¸ì˜¤ë¼ëŠ” ëœ»ì…ë‹ˆë‹¤.
            # ì¥ì :
            #       ì½”ë“œê°€ ê¹”ë”í•¨: ê¸´ ë¬¸ì¥ì„ ë‹¤ ì ì„ í•„ìš” ì—†ì´ í•œ ì¤„ì´ë©´ ëë‚©ë‹ˆë‹¤.
            #       ê²€ì¦ëœ ì„±ëŠ¥: ì „ ì„¸ê³„ ê°œë°œìë“¤ì´ "ì´ê±° ì¨ë³´ë‹ˆ ì˜ ë˜ë”ë¼" í•˜ëŠ” 'êµ­ë£° í”„ë¡¬í”„íŠ¸'ë¥¼ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            # ë‹¨ì :
            #       ë¸”ë™ë°•ìŠ¤: ë‹¤ìš´ë°›ê¸° ì „ì—ëŠ” ë¬´ìŠ¨ ë‚´ìš©ì¸ì§€ ë°”ë¡œ ì•Œê¸° ì–´ë µìŠµë‹ˆë‹¤. (ì¸í„°ë„· ì—°ê²° í•„ìš”)
            prompt = hub.pull("rlm/rag-prompt")

            # 1.2 ì§ì ‘ì“°ê¸° ë°©ì‹  : ChatPromptTemplate.from_template(...)
            # ë°©ì‹: íŒŒì´ì¬ ì½”ë“œ ì•ˆì— í”„ë¡¬í”„íŠ¸(ì§€ì‹œì‚¬í•­) ë‚´ìš©ì„ ì§ì ‘ ë‹¤ ì ì–´ë„£ëŠ” ê²ƒì…ë‹ˆë‹¤.
            # ì¥ì :
            #       ëˆˆì— ë³´ì„: ë‚´ê°€ AIì—ê²Œ ë­ë¼ê³  ì‹œí‚¤ëŠ”ì§€ ì½”ë“œë§Œ ë³´ë©´ ë°”ë¡œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            #       ìˆ˜ì • ì‰¬ì›€: "ì¹œì ˆí•˜ê²Œ ë‹µí•´ì¤˜"ë¥¼ "ë°˜ë§í•´ì¤˜"ë¡œ ë°”ê¾¸ê³  ì‹¶ìœ¼ë©´ ë°”ë¡œ ê³ ì¹˜ë©´ ë©ë‹ˆë‹¤.
            #       ê³µë¶€í•  ë•Œ ì¢‹ìŒ: ì›ë¦¬ë¥¼ ì´í•´í•˜ê¸°ì— ê°€ì¥ ì¢‹ìŠµë‹ˆë‹¤.
            # 
            # {context}: ê²€ìƒ‰ëœ ë¬¸ì„œ ë‚´ìš©ì´ ë“¤ì–´ê°ˆ ìë¦¬
            # {question}: ì‚¬ìš©ìì˜ ì§ˆë¬¸ì´ ë“¤ì–´ê°ˆ ìë¦¬
            # template = """
            # ë‹¹ì‹ ì€ ì§ˆë¬¸ì— ë‹µë³€í•˜ëŠ” ì¹œì ˆí•œ AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤.
            # ì•„ë˜ì˜ [ë¬¸ì„œ ë‚´ìš©]ì„ ì°¸ê³ í•´ì„œ ì§ˆë¬¸ì— ë‹µë³€í•´ ì£¼ì„¸ìš”.

            # [ë¬¸ì„œ ë‚´ìš©]
            # {context}

            # ì§ˆë¬¸: {question}
            # """
            # prompt = ChatPromptTemplate.from_template(template)  


            # 2. ë¬¸ì„œ í•©ì¹˜ê¸° í•¨ìˆ˜ (í’€ì¹ )
            # ê²€ìƒ‰ëœ ë¬¸ì„œ ì¡°ê°(ë¦¬ìŠ¤íŠ¸)ë“¤ì„ "\n\n"(ë‘ ì¤„ ë„ê¸°) ì ‘ì°©ì œë¡œ ì´ì–´ ë¶™ì—¬ í•˜ë‚˜ì˜ ê¸´ ê¸€ë¡œ ë§Œë“­ë‹ˆë‹¤.
            # ë¬¸ì„œë“¤ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ëŠ” í—¬í¼ í•¨ìˆ˜
            # (ê²€ìƒ‰ëœ ì—¬ëŸ¬ í˜ì´ì§€ì˜ ê¸€ìë“¤ì„ í•˜ë‚˜ì˜ ê¸´ ë¬¸ìì—´ë¡œ ì´ì–´ ë¶™ì…ë‹ˆë‹¤)
            # "\n\n".join(...)ì€ "ë¬¸ìì—´ í•©ì²´ í’€"ì…ë‹ˆë‹¤. ğŸ§ª
            # ë„¤, joinì€ **íŒŒì´ì¬ì˜ ê¸°ë³¸ í•¨ìˆ˜(ë©”ì†Œë“œ)**ì…ë‹ˆë‹¤. ì•„ì£¼ ë§ì´ ì“°ì…ë‹ˆë‹¤!
            # ë¦¬ìŠ¤íŠ¸(List)ì— ë‹´ê¸´ ì—¬ëŸ¬ ë¬¸ìì—´ ì¡°ê°ë“¤ì„ í•˜ë‚˜ì˜ ê¸´ ë¬¸ìì—´ë¡œ ì´ì–´ ë¶™ì¼ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
            # 
            # text_list = []                         #1. ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“­ë‹ˆë‹¤.
            # for doc in docs:                       # # 2. ë¬¸ì„œ ë­‰ì¹˜(docs)ì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ì„œ ë‚´ìš©(page_content)ë§Œ ë‹´ìŠµë‹ˆë‹¤.
            #     text_list.append(doc.page_content) # ì§€ê¸ˆ text_list ìƒíƒœ: ["ì•„ë‚´ëŠ” ì„¤ë íƒ•ì„ ì¢‹ì•„í•´", "ê¹€ì²¨ì§€ëŠ” ìŠ¬í¼"]
            # final_text = "\n\n".join(text_list)    # 3. ì ‘ì°©ì œ(\n\n)ë¡œ ì´ì–´ ë¶™ì…ë‹ˆë‹¤.
            # # ìµœì¢… ê²°ê³¼: "ì•„ë‚´ëŠ” ì„¤ë íƒ•ì„ ì¢‹ì•„í•´\n\nê¹€ì²¨ì§€ëŠ” ìŠ¬í¼"
            # 1. \n\nì€ "ë§¨ ì•"ì´ ì•„ë‹ˆë¼ "ì‚¬ì´ì‚¬ì´"ì— ë“¤ì–´ê°‘ë‹ˆë‹¤! ğŸ¥ª
            # ë‹˜ì˜ ìƒê°: "\n\n" + ë¬¸ì„œ1 + ë¬¸ì„œ2 ... (X) ì‹¤ì œ ë™ì‘: ë¬¸ì„œ1 + "\n\n" + ë¬¸ì„œ2 + "\n\n" + ë¬¸ì„œ3 (O)
            # joinì€ "ìƒŒë“œìœ„ì¹˜ ì† ì¬ë£Œ" ê°™ë‹¤ê³  ìƒê°í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
            # "ì ‘ì°©ì œ".join([A, B, C]) ë¼ê³  ì“°ë©´
            # A ì ‘ì°©ì œ B ì ‘ì°©ì œ C ê°€ ë©ë‹ˆë‹¤.
            # (ë§¨ ì•ì´ë‚˜ ë§¨ ë’¤ì—ëŠ” ì•ˆ ë¶™ìŠµë‹ˆë‹¤!)
            # join ê´„í˜¸ ( ) ì•ˆì—ëŠ” **ë¬¸ìì—´ë“¤ì´ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸(List)**ë‚˜ íŠœí”Œ(Tuple), 
            # í˜¹ì€ **ë°˜ë³µ ê°€ëŠ¥í•œ ê°ì²´(Iterable)**ê°€ ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤.
            def format_docs(docs):
                return "\n\n".join(doc.page_content for doc in docs)


            # 3. ì²´ì¸ ì—°ê²° (íŒŒì´í”„ë¼ì¸ ì„¤ê³„ë„)
            # ë¹„ìœ : ìˆ˜ë„ê´€ì„ ì—°ê²°í•˜ëŠ” ì„¤ê³„ë„ì…ë‹ˆë‹¤. (ì—¬ê¸°ì„  ì•„ì§ ë¬¼ì´ íë¥´ì§€ ì•ŠìŒ!)
            # íë¦„:
            #  1) retriever: ì§ˆë¬¸ì„ ë°›ì•„ ë¬¸ì„œë¥¼ ì°¾ì•„ì˜´
            #  2) format_docs: ì°¾ì•„ì˜¨ ë¬¸ì„œë¥¼ ë³´ê¸° ì¢‹ê²Œ ì´ì–´ ë¶™ì„
            #  3) prompt: ì§ˆë¬¸ê³¼ ë¬¸ì„œë¥¼ í•©ì³ì„œ ì§€ë ¹ì„œë¥¼ ì™„ì„±í•¨
            #  4) llm: ì§€ë ¹ì„œë¥¼ ì½ê³  ë‹µë³€ì„ ìƒê°í•¨
            #  5) StrOutputParser: ë‹µë³€ì„ ê¹”ë”í•œ ë¬¸ìì—´ë¡œ ì¶œë ¥í•¨
            # 
            #  ì²´ì¸(Chain) ìƒì„± - ì´ê²Œ ë°”ë¡œ RAGì˜ í•µì‹¬ íŒŒì´í”„ë¼ì¸ì…ë‹ˆë‹¤!
            # íë¦„: ê²€ìƒ‰ê¸°(retriever) -> ë¬¸ì„œ í¬ë§·íŒ… -> í”„ë¡¬í”„íŠ¸ ì±„ìš°ê¸° -> LLMì—ê²Œ ë³´ëƒ„ -> ë¬¸ìì—´ë¡œ ë‹µ ë°›ê¸°
            # ì•„ë˜  rag_chain = ...ì€ "ì„¤ê³„ë„ ê·¸ë¦¬ê¸°"ì…ë‹ˆë‹¤. (ì‹¤í–‰ X)
            # ì§ˆë¬¸í•˜ì‹  ëŒ€ë¡œ, íŒŒì´í”„(|)ê°€ ì—°ê²°ë˜ì–´ ìˆì§€ë§Œ ì´ ì‹œì ì—ì„œëŠ” ë°ì´í„°ê°€ íë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
            # rag_chain = ... (ì´ ë¶€ë¶„):
            # ìˆ˜ë„ê´€ ê³µì‚¬ë¥¼ í•˜ëŠ” ë‹¨ê³„ì…ë‹ˆë‹¤. "ìˆ˜ë„ê¼­ì§€(Retriever)ì™€ ì •ìˆ˜ê¸°(LLM)ë¥¼ íŒŒì´í”„ë¡œ ì—°ê²°í•´ ë†”ë¼"ë¼ê³  ì¡°ë¦½ë§Œ í•´ë‘” ìƒíƒœì…ë‹ˆë‹¤.
            # ë¬¼ì´ íë¥¼ ê¸¸(Path)ë§Œ ë§Œë“¤ì–´ ë‘” ê²ƒì´ì§€, ì•„ì§ ìˆ˜ë„ê¼­ì§€ë¥¼ í‹€ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ë¬¼(ë°ì´í„°)ì€ í•œ ë°©ìš¸ë„ íë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
            # ê·¸ë˜ì„œ format_docs í•¨ìˆ˜ë„ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
            rag_chain = (
                {"context": retriever_from_llm | format_docs, "question": RunnablePassthrough()}
                | prompt
                | llm
                | StrOutputParser()
            )



            # ==========================================
            # [6] ì‹¤í–‰ (ìˆ˜ë„ê¼­ì§€ í‹€ê¸°!)
            # ==========================================
            # .invoke(question) (ì´ ë¶€ë¶„):
            # ì´ì œ ë©”ì¸ ë°¸ë¸Œë¥¼ ì—¬ëŠ” ìˆœê°„ì…ë‹ˆë‹¤.
            # ì´ë•Œ ë¹„ë¡œì†Œ ì§ˆë¬¸(question)ì´ë¼ëŠ” ë¬¼ì´ ì½¸ì½¸ ìŸì•„ì ¸ ë“¤ì–´ì˜¤ë©°, 
            # ì•„ê¹Œ ì—°ê²°í•´ ë‘” íŒŒì´í”„(|)ë¥¼ íƒ€ê³  retrieverë¡œ ê°”ë‹¤ê°€ 
            # -> format_docsë¡œ ê°”ë‹¤ê°€ 
            # -> llmìœ¼ë¡œ í˜ëŸ¬ê°€ëŠ” ê²ƒì…ë‹ˆë‹¤.

            #Question

            result = rag_chain.invoke(question)
            # print(result)
            st.write(result)